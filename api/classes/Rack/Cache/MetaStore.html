<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Rack::Cache::MetaStore</title>
<meta content='text/html; charset=utf8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>class</span>
Rack::Cache::MetaStore
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/rack/cache/meta_store_rb.html">lib/rack/cache/meta_store.rb</a>
</li>
</ol>
<div class='parent'>
Superclass:
<strong>Object</strong>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The <a href="MetaStore.html"><code>MetaStore</code></a> is responsible for storing meta information about a request/response pair keyed by the request’s URL.</p>

<p>The meta store keeps a list of request/response pairs for each canonical request URL. A request/response pair is a two element Array of the form:</p>

<pre class="ruby">[<span class="ruby-identifier">request</span>, <span class="ruby-identifier">response</span>]
</pre>

<p>The <code>request</code> element is a Hash of <a href="../../Rack.html"><code>Rack</code></a> environment keys. Only protocol keys (i.e., those that start with “HTTP_”) are stored. The <code>response</code> element is a Hash of cached HTTP response headers for the paired request.</p>

<p>The <a href="MetaStore.html"><code>MetaStore</code></a> class is abstract and should not be instanstiated directly. Concrete subclasses should implement the protected <a href="MetaStore.html#method-i-read"><code>read</code></a>, <a href="MetaStore.html#method-i-write"><code>write</code></a>, and <a href="MetaStore.html#method-i-purge"><code>purge</code></a> methods. Care has been taken to keep these low-level methods dumb and straight-forward to implement.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Instance</h3>
<ol>
<li><a href="#method-i-cache_key">cache_key</a></li>
<li><a href="#method-i-invalidate">invalidate</a></li>
<li><a href="#method-i-lookup">lookup</a></li>
<li><a href="#method-i-store">store</a></li>
</ol>
<h3>Protected Instance</h3>
<ol>
<li><a href="#method-i-purge">purge</a></li>
<li><a href="#method-i-read">read</a></li>
<li><a href="#method-i-write">write</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="MetaStore/Disk.html">Rack::Cache::MetaStore::DISK</a></li>
<li><a href="MetaStore/Dalli.html">Rack::Cache::MetaStore::Dalli</a></li>
<li><a href="MetaStore/Disk.html">Rack::Cache::MetaStore::Disk</a></li>
<li><a href="MetaStore/Disk.html">Rack::Cache::MetaStore::FILE</a></li>
<li><a href="MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAE</a></li>
<li><a href="MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAECACHE</a></li>
<li><a href="MetaStore/GAEStore.html">Rack::Cache::MetaStore::GAEStore</a></li>
<li><a href="MetaStore/Heap.html">Rack::Cache::MetaStore::HEAP</a></li>
<li><a href="MetaStore/Heap.html">Rack::Cache::MetaStore::Heap</a></li>
<li><a href="MetaStore/HEAP.html">Rack::Cache::MetaStore::MEM</a></li>
<li><a href="MetaStore/MemCacheBase.html">Rack::Cache::MetaStore::MemCacheBase</a></li>
<li><a href="MetaStore/MemCached.html">Rack::Cache::MetaStore::MemCached</a></li>
</ol>
</div>
<div id='section'>
<div id='constants-list'>
<h2>Constants</h2>
<div class='name-list'>
<table summary='Constants'>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>DISK</td>
<td>=</td>
<td class='context-item-value'>Disk</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Concrete <a href="MetaStore.html"><code>MetaStore</code></a> implementation that stores request/response pairs on disk.</p>
</td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>FILE</td>
<td>=</td>
<td class='context-item-value'>Disk</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Concrete <a href="MetaStore.html"><code>MetaStore</code></a> implementation that stores request/response pairs on disk.</p>
</td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>GAE</td>
<td>=</td>
<td class='context-item-value'>GAEStore</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>GAECACHE</td>
<td>=</td>
<td class='context-item-value'>GAEStore</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>HEAP</td>
<td>=</td>
<td class='context-item-value'>Heap</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Concrete <a href="MetaStore.html"><code>MetaStore</code></a> implementation that uses a simple Hash to store request/response pairs on the heap.</p>
</td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>MEM</td>
<td>=</td>
<td class='context-item-value'>HEAP</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Concrete <a href="MetaStore.html"><code>MetaStore</code></a> implementation that uses a simple Hash to store request/response pairs on the heap.</p>
</td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>MEMCACHE</td>
<td>=</td>
<td class='context-item-value'>if defined?(::Memcached)
MemCached
else
Dalli
end</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>MEMCACHED</td>
<td>=</td>
<td class='context-item-value'>MEMCACHE</td>
<td>&nbsp;</td>
<td class='context-item-desc'></td>
</tr>
</table>
</div>
</div>
<div id='methods'>
<h2>Public Instance methods</h2>
<div class='method public-instance' id='method-method-i-cache_key'>
<a name='method-i-cache_key'></a>
<div class='synopsis'>
<span class='name'>cache_key</span><span class='arguments'>(request)</span>

</div>
<div class='description'>

<p>Generate a cache key for the request.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-cache_key-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-cache_key-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">112</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">cache_key</span>(<span class="ruby-identifier">request</span>)
<span class="line-num">113</span>   <span class="ruby-identifier">keygen</span> = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;rack-cache.cache_key&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">Key</span>
<span class="line-num">114</span>   <span class="ruby-identifier">keygen</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">request</span>)
<span class="line-num">115</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method public-instance' id='method-method-i-invalidate'>
<a name='method-i-invalidate'></a>
<div class='synopsis'>
<span class='name'>invalidate</span><span class='arguments'>(request, entity_store)</span>

</div>
<div class='description'>

<p>Invalidate all cache entries that match the request.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-invalidate-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-invalidate-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">118</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">invalidate</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">entity_store</span>)
<span class="line-num">119</span>   <span class="ruby-identifier">modified</span> = <span class="ruby-keyword">false</span>
<span class="line-num">120</span>   <span class="ruby-identifier">key</span> = <span class="ruby-identifier">cache_key</span>(<span class="ruby-identifier">request</span>)
<span class="line-num">121</span>   <span class="ruby-identifier">entries</span> =
<span class="line-num">122</span>     <span class="ruby-identifier">read</span>(<span class="ruby-identifier">key</span>).<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">req</span>, <span class="ruby-identifier">res</span><span class="ruby-operator">|</span>
<span class="line-num">123</span>       <span class="ruby-identifier">response</span> = <span class="ruby-identifier">restore_response</span>(<span class="ruby-identifier">res</span>)
<span class="line-num">124</span>       <span class="ruby-keyword">if</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">fresh?</span>
<span class="line-num">125</span>         <span class="ruby-identifier">response</span>.<span class="ruby-identifier">expire!</span>
<span class="line-num">126</span>         <span class="ruby-identifier">modified</span> = <span class="ruby-keyword">true</span>
<span class="line-num">127</span>         [<span class="ruby-identifier">req</span>, <span class="ruby-identifier">persist_response</span>(<span class="ruby-identifier">response</span>)]
<span class="line-num">128</span>       <span class="ruby-keyword">else</span>
<span class="line-num">129</span>         [<span class="ruby-identifier">req</span>, <span class="ruby-identifier">res</span>]
<span class="line-num">130</span>       <span class="ruby-keyword">end</span>
<span class="line-num">131</span>     <span class="ruby-keyword">end</span>
<span class="line-num">132</span>   <span class="ruby-identifier">write</span> <span class="ruby-identifier">key</span>, <span class="ruby-identifier">entries</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">modified</span>
<span class="line-num">133</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method public-instance' id='method-method-i-lookup'>
<a name='method-i-lookup'></a>
<div class='synopsis'>
<span class='name'>lookup</span><span class='arguments'>(request, entity_store)</span>

</div>
<div class='description'>

<p>Locate a cached response for the request provided. Returns a <a href="Response.html"><code>Rack::Cache::Response</code></a> object if the cache hits or nil if no cache entry was found.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-lookup-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-lookup-source'>   <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">28</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">lookup</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">entity_store</span>)
<span class="line-num">29</span>   <span class="ruby-identifier">key</span> = <span class="ruby-identifier">cache_key</span>(<span class="ruby-identifier">request</span>)
<span class="line-num">30</span>   <span class="ruby-identifier">entries</span> = <span class="ruby-identifier">read</span>(<span class="ruby-identifier">key</span>)
<span class="line-num">31</span> 
<span class="line-num">32</span>   <span class="ruby-comment"># bail out if we have nothing cached</span>
<span class="line-num">33</span>   <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">empty?</span>
<span class="line-num">34</span> 
<span class="line-num">35</span>   <span class="ruby-comment"># find a cached entry that matches the request.</span>
<span class="line-num">36</span>   <span class="ruby-identifier">env</span> = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">env</span>
<span class="line-num">37</span>   <span class="ruby-identifier">match</span> = <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">detect</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">req</span>,<span class="ruby-identifier">res</span><span class="ruby-operator">|</span> <span class="ruby-identifier">requests_match?</span>((<span class="ruby-identifier">res</span>[<span class="ruby-string">&#39;vary&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">res</span>[<span class="ruby-string">&#39;vary&#39;</span>]), <span class="ruby-identifier">env</span>, <span class="ruby-identifier">req</span>) }
<span class="line-num">38</span>   <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">match</span>.<span class="ruby-identifier">nil?</span>
<span class="line-num">39</span> 
<span class="line-num">40</span>   <span class="ruby-identifier">_</span>, <span class="ruby-identifier">res</span> = <span class="ruby-identifier">match</span>
<span class="line-num">41</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">body</span> = <span class="ruby-identifier">entity_store</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">res</span>[<span class="ruby-string">&#39;x-content-digest&#39;</span>])
<span class="line-num">42</span>     <span class="ruby-identifier">restore_response</span>(<span class="ruby-identifier">res</span>, <span class="ruby-identifier">body</span>)
<span class="line-num">43</span>   <span class="ruby-keyword">else</span>
<span class="line-num">44</span>     <span class="ruby-comment"># the metastore referenced an entity that doesn&#39;t exist in</span>
<span class="line-num">45</span>     <span class="ruby-comment"># the entitystore, purge the entry from the meta-store</span>
<span class="line-num">46</span>     <span class="ruby-keyword">begin</span>
<span class="line-num">47</span>       <span class="ruby-identifier">purge</span>(<span class="ruby-identifier">key</span>)
<span class="line-num">48</span>     <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NotImplementedError</span>
<span class="line-num">49</span>       <span class="ruby-identifier">@@warned_on_purge</span> <span class="ruby-operator">||=</span> <span class="ruby-keyword">begin</span>
<span class="line-num">50</span>         <span class="ruby-identifier">warn</span> <span class="ruby-node">&quot;WARNING: Future releases may require purge implementation for #{self.class.name}&quot;</span>
<span class="line-num">51</span>         <span class="ruby-keyword">true</span>
<span class="line-num">52</span>       <span class="ruby-keyword">end</span>
<span class="line-num">53</span>       <span class="ruby-keyword">nil</span>
<span class="line-num">54</span>     <span class="ruby-keyword">end</span>
<span class="line-num">55</span>   <span class="ruby-keyword">end</span>
<span class="line-num">56</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method public-instance' id='method-method-i-store'>
<a name='method-i-store'></a>
<div class='synopsis'>
<span class='name'>store</span><span class='arguments'>(request, response, entity_store)</span>

</div>
<div class='description'>

<p>Write a cache entry to the store under the given key. Existing entries are read and any that match the response are removed. This method calls <a href="MetaStore.html#method-i-write"><code>write</code></a> with the new list of cache entries.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-store-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-store-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num"> 61</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">store</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">response</span>, <span class="ruby-identifier">entity_store</span>)
<span class="line-num"> 62</span>   <span class="ruby-identifier">key</span> = <span class="ruby-identifier">cache_key</span>(<span class="ruby-identifier">request</span>)
<span class="line-num"> 63</span>   <span class="ruby-identifier">stored_env</span> = <span class="ruby-identifier">persist_request</span>(<span class="ruby-identifier">request</span>)
<span class="line-num"> 64</span> 
<span class="line-num"> 65</span>   <span class="ruby-comment"># write the response body to the entity store if this is the</span>
<span class="line-num"> 66</span>   <span class="ruby-comment"># original response.</span>
<span class="line-num"> 67</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;x-content-digest&#39;</span>].<span class="ruby-identifier">nil?</span>
<span class="line-num"> 68</span>     <span class="ruby-keyword">if</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;rack-cache.use_native_ttl&#39;</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">fresh?</span>
<span class="line-num"> 69</span>       <span class="ruby-identifier">digest</span>, <span class="ruby-identifier">size</span> = <span class="ruby-identifier">entity_store</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>, <span class="ruby-identifier">response</span>.<span class="ruby-identifier">ttl</span>)
<span class="line-num"> 70</span>     <span class="ruby-keyword">else</span>
<span class="line-num"> 71</span>       <span class="ruby-identifier">digest</span>, <span class="ruby-identifier">size</span> = <span class="ruby-identifier">entity_store</span>.<span class="ruby-identifier">write</span>(<span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>)
<span class="line-num"> 72</span>     <span class="ruby-keyword">end</span>
<span class="line-num"> 73</span>     <span class="ruby-identifier">response</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;x-content-digest&#39;</span>] = <span class="ruby-identifier">digest</span>
<span class="line-num"> 74</span>     <span class="ruby-identifier">response</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;content-length&#39;</span>] = <span class="ruby-identifier">size</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;Transfer-Encoding&#39;</span>]
<span class="line-num"> 75</span> 
<span class="line-num"> 76</span>     <span class="ruby-comment"># If the entitystore backend is a Noop, do not try to read the body from the backend, it always returns an empty array</span>
<span class="line-num"> 77</span>     <span class="ruby-keyword">unless</span> <span class="ruby-identifier">entity_store</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">Cache</span><span class="ruby-operator">::</span><span class="ruby-constant">EntityStore</span><span class="ruby-operator">::</span><span class="ruby-constant">Noop</span>
<span class="line-num"> 78</span>       <span class="ruby-comment"># A stream body can only be read once and is currently closed by #write.</span>
<span class="line-num"> 79</span>       <span class="ruby-comment"># (To avoid having to keep giant objects in memory when writing to disk cache</span>
<span class="line-num"> 80</span>       <span class="ruby-comment"># the body is never converted to a single string)</span>
<span class="line-num"> 81</span>       <span class="ruby-comment"># We cannot always reply on body to be re-readable,</span>
<span class="line-num"> 82</span>       <span class="ruby-comment"># so we have to read it from the cache.</span>
<span class="line-num"> 83</span>       <span class="ruby-comment"># BUG: if the cache was unable to store a stream, the stream will be closed</span>
<span class="line-num"> 84</span>       <span class="ruby-comment">#      and rack will try to read it again, resulting in hard to track down exception</span>
<span class="line-num"> 85</span>       <span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">entity_store</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">digest</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>
<span class="line-num"> 86</span>     <span class="ruby-keyword">end</span>
<span class="line-num"> 87</span>   <span class="ruby-keyword">end</span>
<span class="line-num"> 88</span> 
<span class="line-num"> 89</span>   <span class="ruby-comment"># read existing cache entries, remove non-varying, and add this one to</span>
<span class="line-num"> 90</span>   <span class="ruby-comment"># the list</span>
<span class="line-num"> 91</span>   <span class="ruby-identifier">vary</span> = <span class="ruby-identifier">response</span>.<span class="ruby-identifier">vary</span>
<span class="line-num"> 92</span>   <span class="ruby-identifier">entries</span> =
<span class="line-num"> 93</span>     <span class="ruby-identifier">read</span>(<span class="ruby-identifier">key</span>).<span class="ruby-identifier">reject</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">env</span>, <span class="ruby-identifier">res</span><span class="ruby-operator">|</span>
<span class="line-num"> 94</span>       (<span class="ruby-identifier">vary</span> <span class="ruby-operator">==</span> (<span class="ruby-identifier">res</span>[<span class="ruby-string">&#39;vary&#39;</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">res</span>[<span class="ruby-string">&#39;vary&#39;</span>])) <span class="ruby-operator">&amp;&amp;</span>
<span class="line-num"> 95</span>         <span class="ruby-identifier">requests_match?</span>(<span class="ruby-identifier">vary</span>, <span class="ruby-identifier">env</span>, <span class="ruby-identifier">stored_env</span>)
<span class="line-num"> 96</span>     <span class="ruby-keyword">end</span>
<span class="line-num"> 97</span> 
<span class="line-num"> 98</span>   <span class="ruby-identifier">headers</span> = <span class="ruby-identifier">persist_response</span>(<span class="ruby-identifier">response</span>)
<span class="line-num"> 99</span>   <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&#39;age&#39;</span>)
<span class="line-num">100</span>   <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">&#39;age&#39;</span>)
<span class="line-num">101</span> 
<span class="line-num">102</span>   <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">unshift</span> [<span class="ruby-identifier">stored_env</span>, <span class="ruby-identifier">headers</span>]
<span class="line-num">103</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">request</span>.<span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;rack-cache.use_native_ttl&#39;</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">response</span>.<span class="ruby-identifier">fresh?</span>
<span class="line-num">104</span>     <span class="ruby-identifier">write</span> <span class="ruby-identifier">key</span>, <span class="ruby-identifier">entries</span>, <span class="ruby-identifier">response</span>.<span class="ruby-identifier">ttl</span>
<span class="line-num">105</span>   <span class="ruby-keyword">else</span>
<span class="line-num">106</span>     <span class="ruby-identifier">write</span> <span class="ruby-identifier">key</span>, <span class="ruby-identifier">entries</span>
<span class="line-num">107</span>   <span class="ruby-keyword">end</span>
<span class="line-num">108</span>   <span class="ruby-identifier">key</span>
<span class="line-num">109</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<h2>Protected Instance methods</h2>
<div class='method protected-instance' id='method-method-i-purge'>
<a name='method-i-purge'></a>
<div class='synopsis'>
<span class='name'>purge</span><span class='arguments'>(key)</span>

</div>
<div class='description'>

<p>Remove all cached entries at the key specified. No error is raised when the key does not exist.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-purge-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-purge-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">187</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">purge</span>(<span class="ruby-identifier">key</span>)
<span class="line-num">188</span>   <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>
<span class="line-num">189</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method protected-instance' id='method-method-i-read'>
<a name='method-i-read'></a>
<div class='synopsis'>
<span class='name'>read</span><span class='arguments'>(key)</span>

</div>
<div class='description'>

<p>Locate all cached request/response pairs that match the specified URL key. The result must be an Array of all cached request/response pairs. An empty Array must be returned if nothing is cached for the specified key.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-read-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-read-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">174</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">read</span>(<span class="ruby-identifier">key</span>)
<span class="line-num">175</span>   <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>
<span class="line-num">176</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method protected-instance' id='method-method-i-write'>
<a name='method-i-write'></a>
<div class='synopsis'>
<span class='name'>write</span><span class='arguments'>(key, negotiations, ttl = nil)</span>

</div>
<div class='description'>

<p>Store an Array of request/response pairs for the given key. Concrete implementations should not attempt to filter or concatenate the list in any way.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-i-write-source&#39;); return false'>
[show source]
</a>
<pre id='method-i-write-source'>    <span class="ruby-comment"># File lib/rack/cache/meta_store.rb</span>
<span class="line-num">181</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">write</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">negotiations</span>, <span class="ruby-identifier">ttl</span> = <span class="ruby-keyword">nil</span>)
<span class="line-num">182</span>   <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>
<span class="line-num">183</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
